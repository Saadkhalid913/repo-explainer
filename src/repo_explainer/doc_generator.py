"""Documentation generator - Markdown writer, TOC builder, index creation."""

from datetime import datetime
from pathlib import Path
from typing import Optional

from repo_explainer.models import (
    AnalysisResult,
    ComponentInfo,
    DiagramInfo,
    DiagramType,
    RepositoryInfo,
)


class DocumentationGenerator:
    """Generates markdown documentation from analysis results."""

    def __init__(self, output_dir: Path):
        self.output_dir = output_dir
        self._ensure_directories()

    def _ensure_directories(self) -> None:
        """Create the output directory structure."""
        dirs = [
            self.output_dir,
            self.output_dir / "architecture",
            self.output_dir / "architecture" / "diagrams",
            self.output_dir / "components",
            self.output_dir / "data-models",
            self.output_dir / "data-models" / "diagrams",
            self.output_dir / "dependencies",
            self.output_dir / "dependencies" / "diagrams",
            self.output_dir / "patterns",
            self.output_dir / "metadata",
        ]
        for d in dirs:
            d.mkdir(parents=True, exist_ok=True)

    def generate_index(
        self,
        repo_info: RepositoryInfo,
        components: list[ComponentInfo],
        diagrams: list[DiagramInfo],
    ) -> Path:
        """Generate the main index.md file."""
        content = f"""\
# {repo_info.name} - Repository Documentation

> Auto-generated documentation by repo-explainer

## Overview

| Property | Value |
|----------|-------|
| **Primary Language** | {repo_info.primary_language.value if repo_info.primary_language else 'Unknown'} |
| **All Languages** | {', '.join(l.value for l in repo_info.languages) or 'None detected'} |
| **Size** | {repo_info.size_category.value} ({repo_info.file_count:,} files) |
| **Total Lines** | {repo_info.total_lines:,} |
| **Last Analyzed** | {repo_info.last_analyzed.strftime('%Y-%m-%d %H:%M:%S') if repo_info.last_analyzed else 'N/A'} |
"""

        if repo_info.git_remote:
            content += f"| **Git Remote** | {repo_info.git_remote} |\n"
        if repo_info.git_branch:
            content += f"| **Branch** | {repo_info.git_branch} |\n"
        if repo_info.git_commit:
            content += f"| **Commit** | {repo_info.git_commit} |\n"

        content += """
## Table of Contents

### Architecture
- [Architecture Overview](architecture/overview.md)
- [System Architecture](architecture/system-architecture.md)

### Components
"""
        for component in components:
            content += f"- [{component.name}](components/{component.id}/overview.md)\n"

        content += """
### Diagrams
"""
        for diagram in diagrams:
            rel_path = diagram.output_path.relative_to(self.output_dir) if diagram.output_path else ""
            content += f"- [{diagram.title}]({rel_path})\n"

        # Embed diagrams inline for visual learners
        if diagrams:
            content += """
## Visual Overview

"""
            for diagram in diagrams:
                content += f"### {diagram.title}\n\n"
                content += f"```mermaid\n{diagram.mermaid_code}\n```\n\n"

        content += """
### Additional
- [Dependencies](dependencies/internal.md)
- [Patterns](patterns/identified-patterns.md)

---

*Generated by [repo-explainer](https://github.com/your-org/repo-explainer)*
"""

        index_path = self.output_dir / "index.md"
        index_path.write_text(content)
        return index_path

    def generate_architecture_overview(
        self,
        repo_info: RepositoryInfo,
        components: list[ComponentInfo],
        diagrams: Optional[list[DiagramInfo]] = None,
        llm_content: Optional[str] = None,
    ) -> Path:
        """Generate architecture overview document."""
        content = f"""\
# Architecture Overview

## {repo_info.name}

"""
        if llm_content:
            content += llm_content
        else:
            content += f"""\
This repository is a {repo_info.size_category.value}-sized project primarily written in \
{repo_info.primary_language.value if repo_info.primary_language else 'multiple languages'}.

"""

        # Embed architecture diagram if available
        if diagrams:
            arch_diagrams = [d for d in diagrams if d.diagram_type in (DiagramType.ARCHITECTURE, DiagramType.COMPONENT)]
            if arch_diagrams:
                content += "## System Architecture\n\n"
                for diag in arch_diagrams:
                    content += f"### {diag.title}\n\n"
                    content += f"```mermaid\n{diag.mermaid_code}\n```\n\n"

        content += "## Key Components\n\n"
        for component in components:
            content += f"""\
### {component.name}
- **Type**: {component.component_type}
- **Path**: `{component.path}`
- **Files**: {len(component.files)} source files

"""

        # Embed dataflow diagram if available
        if diagrams:
            flow_diagrams = [d for d in diagrams if d.diagram_type == DiagramType.DATAFLOW]
            if flow_diagrams:
                content += "## Data Flow\n\n"
                for diag in flow_diagrams:
                    content += f"```mermaid\n{diag.mermaid_code}\n```\n\n"

        overview_path = self.output_dir / "architecture" / "overview.md"
        overview_path.write_text(content)
        return overview_path

    def generate_component_doc(self, component: ComponentInfo) -> Path:
        """Generate documentation for a single component."""
        component_dir = self.output_dir / "components" / component.id
        component_dir.mkdir(parents=True, exist_ok=True)

        content = f"""\
# {component.name}

## Overview

- **Type**: {component.component_type}
- **Path**: `{component.path}`

## Description

{component.description or 'No description available.'}

## Responsibilities

"""
        if component.responsibilities:
            for resp in component.responsibilities:
                content += f"- {resp}\n"
        else:
            content += "- *To be documented*\n"

        content += """
## Dependencies

### Internal
"""
        if component.dependencies:
            for dep in component.dependencies:
                content += f"- {dep}\n"
        else:
            content += "- None identified\n"

        content += """
### External
"""
        if component.external_dependencies:
            for dep in component.external_dependencies:
                content += f"- {dep}\n"
        else:
            content += "- None identified\n"

        content += """
## Key Files

"""
        for file_path in component.files[:20]:  # Limit to first 20
            content += f"- `{file_path}`\n"

        if len(component.files) > 20:
            content += f"\n*...and {len(component.files) - 20} more files*\n"

        doc_path = component_dir / "overview.md"
        doc_path.write_text(content)
        return doc_path

    def generate_dependencies_doc(
        self,
        components: list[ComponentInfo],
        external_deps: Optional[list[str]] = None,
    ) -> Path:
        """Generate dependencies documentation."""
        content = """\
# Dependencies

## Internal Dependencies

Component dependency graph:

"""
        for component in components:
            if component.dependencies:
                content += f"### {component.name}\n"
                for dep in component.dependencies:
                    content += f"- â†’ {dep}\n"
                content += "\n"

        content += """
## External Dependencies

"""
        if external_deps:
            for dep in external_deps:
                content += f"- {dep}\n"
        else:
            content += "*Run with --deep flag to extract external dependencies*\n"

        deps_path = self.output_dir / "dependencies" / "internal.md"
        deps_path.write_text(content)
        return deps_path

    def generate_patterns_doc(
        self,
        patterns: list[str],
        llm_content: Optional[str] = None,
    ) -> Path:
        """Generate patterns documentation."""
        content = """\
# Identified Patterns

## Architectural Patterns

"""
        if llm_content:
            content += llm_content
        elif patterns:
            for pattern in patterns:
                content += f"- {pattern}\n"
        else:
            content += "*No patterns explicitly identified. Run with --deep flag for pattern detection.*\n"

        patterns_path = self.output_dir / "patterns" / "identified-patterns.md"
        patterns_path.write_text(content)
        return patterns_path

    def ingest_opencode_output(self, output_files: list[Path]) -> None:
        """
        Ingest files generated by OpenCode and organize them.

        Moves/copies OpenCode outputs to appropriate locations in the
        documentation structure.
        """
        for file_path in output_files:
            if not file_path.exists():
                continue

            name_lower = file_path.name.lower()

            # Determine destination based on filename
            if "architecture" in name_lower:
                dest = self.output_dir / "architecture" / file_path.name
            elif "component" in name_lower and file_path.suffix == ".mmd":
                dest = self.output_dir / "architecture" / "diagrams" / file_path.name
            elif "dataflow" in name_lower or "data-flow" in name_lower:
                dest = self.output_dir / "architecture" / "diagrams" / file_path.name
            elif "tech-stack" in name_lower or "techstack" in name_lower:
                dest = self.output_dir / file_path.name
            elif file_path.suffix == ".mmd":
                dest = self.output_dir / "architecture" / "diagrams" / file_path.name
            else:
                dest = self.output_dir / file_path.name

            dest.parent.mkdir(parents=True, exist_ok=True)

            # Copy content (in case source is in temp directory)
            content = file_path.read_text()
            dest.write_text(content)

    def write_tech_stack(self, tech_stack: list[str]) -> Path:
        """Write technology stack file."""
        content = "# Technology Stack\n\n"
        for tech in tech_stack:
            content += f"- {tech}\n"

        tech_path = self.output_dir / "tech-stack.txt"
        tech_path.write_text(content)
        return tech_path
