{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Repository Analysis Repository: kubernetes Path: tmp/kubernetes/kubernetes Analysis Depth: deep Timestamp: 20260117_162748 Overview This documentation provides a comprehensive analysis of the repository structure, components, data flow, and technology stack. Quick Navigation \ud83d\udce6 Components - System components and architecture \ud83d\udd04 Data Flow - How data moves through the system \ud83d\udee0\ufe0f Technology Stack - Technologies and frameworks used \ud83d\udcd0 Architecture Details - Full architecture analysis Visualizations Component Structure View detailed component documentation \u2192 Data Flow View detailed data flow documentation \u2192 Analysis Artifacts This analysis generated the following artifacts: src/raw/architecture.md - Detailed architecture analysis src/raw/components.mermaid - Component diagram source src/raw/dataflow.mermaid - Data flow diagram source src/raw/tech-stack.txt - Raw technology stack Generated by repo-explainer on 2026-01-17 16:27:51","title":"Repository Analysis"},{"location":"index.html#repository-analysis","text":"Repository: kubernetes Path: tmp/kubernetes/kubernetes Analysis Depth: deep Timestamp: 20260117_162748","title":"Repository Analysis"},{"location":"index.html#overview","text":"This documentation provides a comprehensive analysis of the repository structure, components, data flow, and technology stack.","title":"Overview"},{"location":"index.html#quick-navigation","text":"\ud83d\udce6 Components - System components and architecture \ud83d\udd04 Data Flow - How data moves through the system \ud83d\udee0\ufe0f Technology Stack - Technologies and frameworks used \ud83d\udcd0 Architecture Details - Full architecture analysis","title":"Quick Navigation"},{"location":"index.html#visualizations","text":"","title":"Visualizations"},{"location":"index.html#component-structure","text":"View detailed component documentation \u2192","title":"Component Structure"},{"location":"index.html#data-flow","text":"View detailed data flow documentation \u2192","title":"Data Flow"},{"location":"index.html#analysis-artifacts","text":"This analysis generated the following artifacts: src/raw/architecture.md - Detailed architecture analysis src/raw/components.mermaid - Component diagram source src/raw/dataflow.mermaid - Data flow diagram source src/raw/tech-stack.txt - Raw technology stack Generated by repo-explainer on 2026-01-17 16:27:51","title":"Analysis Artifacts"},{"location":"components/overview.html","text":"Components Overview Architecture Overview Architecture Overview Kubernetes Architecture Executive Summary Kubernetes is a production-grade container orchestration system designed to automate the deployment, scaling, and management of containerized applications. It provides a platform-agnostic way to manage clusters of hosts (nodes) and the workloads running on them. The system follows a decoupled, asynchronous, and declarative design. Users describe the \"desired state\" of the system through the API, and various independent controllers work continuously to transition the \"actual state\" toward that desired state. This reconciliation loop is the fundamental pattern of Kubernetes. System Purpose & Design Philosophy Problem Solved: Managing microservices at scale, handling failures automatically, and optimizing resource utilization across a cluster of machines. Design Goals: Scalability: Capable of managing thousands of nodes and tens of thousands of pods. High Availability: No single point of failure in the control plane. Extensibility: Almost every component can be replaced or extended (CRDs, Admission Webhooks, CNI, CSI). Portability: Runs on public clouds, private clouds, and bare metal. Architecture at a Glance Architectural Style Kubernetes uses a Modular Monorepo structure. It is composed of a central Control Plane that manages the cluster and a set of Nodes that run the actual workloads. Communication is centralized through the API Server; no other control plane component talks directly to etcd or to each other. Core Subsystems API Server ( cmd/kube-apiserver ) - The central gateway for all cluster operations. etcd (External) - Distributed storage for cluster state. Scheduler ( cmd/kube-scheduler ) - Decides where to place workloads. Controller Manager ( cmd/kube-controller-manager ) - Handles routine cluster tasks (node management, replication). Kubelet ( cmd/kubelet ) - The primary agent running on each node. Kube Proxy ( cmd/kube-proxy ) - Manages network rules on nodes. Detailed Component Analysis Component: API Server Purpose: Serves the Kubernetes API and acts as the \"brain\" of the cluster. Location: cmd/kube-apiserver Key Responsibilities: - Validates and configures data for API objects. - Provides RESTful entry points for clients and other components. - Manages authentication, authorization, and admission control. - Directly interacts with etcd for persistence. Core Abstractions: - GenericAPIServer - The base server logic. - Registry - Logic for storing and retrieving objects from etcd. Entry Points: - cmd/kube-apiserver/main.go -> app.NewAPIServerCommand() Component: Scheduler Purpose: Assigns unscheduled Pods to Nodes. Location: cmd/kube-scheduler Key Responsibilities: - Filters nodes (Predicates) based on resource requirements, constraints, and affinity. - Ranks remaining nodes (Priorities) to find the best fit. - Updates the Pod object with the selected Node name (Binding). Extension Points: - Scheduling Framework - Allows adding custom plugins for sorting, filtering, and scoring nodes. Component: Kubelet Purpose: Ensures that containers are running in a Pod on a specific node. Location: cmd/kubelet Key Responsibilities: - Watches the API Server for Pods assigned to its node. - Interacts with the Container Runtime (via CRI) to start/stop containers. - Reports node and pod status back to the API Server. - Performs health checks (Liveness/Readiness probes). Interactions: - Consumes: Pod definitions from API Server. - Provides: Container management on the host. Component: Controller Manager Purpose: Runs controller processes that regulate the state of the cluster. Location: cmd/kube-controller-manager Key Responsibilities: - Node Controller: Notices when nodes go down. - Job Controller: Watches for Job objects and creates Pods to run them. - EndpointSlice Controller: Populates EndpointSlices for services. Data Flow & Communication Primary Data Flows Desired State Update: User -> kubectl -> API Server -> etcd. Scheduling Loop: API Server (Watch) -> Scheduler -> API Server (Binding) -> etcd. Execution Loop: API Server (Watch) -> Kubelet -> Container Runtime (CRI). Communication Patterns Synchronous: REST over HTTP/gRPC for API calls. Asynchronous: The Watch mechanism allows components to be notified of changes in real-time without polling. Persistence: All cluster state is stored in etcd . Directory Structure Guide kubernetes/ \u251c\u2500\u2500 cmd/ # Entry points for all binaries \u2502 \u251c\u2500\u2500 kube-apiserver/ # Control plane API server \u2502 \u251c\u2500\u2500 kubelet/ # Node agent \u2502 \u2514\u2500\u2500 kubectl/ # CLI tool \u251c\u2500\u2500 pkg/ # Core library code (private to this repo) \u2502 \u251c\u2500\u2500 apis/ # Internal API types and conversions \u2502 \u251c\u2500\u2500 controller/ # Logic for various controllers \u2502 \u2514\u2500\u2500 kubelet/ # Detailed implementation of the kubelet \u251c\u2500\u2500 api/ # OpenAPI and Swagger definitions \u251c\u2500\u2500 staging/ # Published libraries (k8s.io/*) \u2502 \u251c\u2500\u2500 src/k8s.io/api/ # Versioned API types \u2502 \u251c\u2500\u2500 src/k8s.io/client-go/# Go client library \u2502 \u2514\u2500\u2500 src/k8s.io/apiserver/# API server framework \u251c\u2500\u2500 test/ # Integration and E2E tests \u2514\u2500\u2500 hack/ # Scripts for building, linting, and codegen Key Interfaces & Abstractions Interface: CRI (Container Runtime Interface) Location: staging/src/k8s.io/cri-api/pkg/apis/services.go (approx) Purpose: Standard interface between the Kubelet and the container runtime. Implementations: containerd, CRI-O, Docker (via shim). Interface: Informer Location: staging/src/k8s.io/client-go/informers/ Purpose: Provides a local cache and event notifications for API objects to minimize API server load. Development Guide Building Use the provided Makefile: make To build a specific component: make WHAT=cmd/kube-apiserver Testing Unit Tests: go test ./pkg/scheduler/... Integration Tests: make test-integration E2E Tests: Use hack/ginkgo-e2e.sh or kind . Glossary Pod: The smallest deployable unit in Kubernetes, containing one or more containers. Node: A worker machine (VM or physical) in the cluster. CRD (Custom Resource Definition): A way to extend the Kubernetes API with your own objects. Admission Controller: A piece of code that intercepts requests to the API server prior to persistence. Component Diagram View Mermaid Source graph TB subgraph \"Control Plane\" API[API Server<br/>cmd/kube-apiserver] Scheduler[Scheduler<br/>cmd/kube-scheduler] CM[Controller Manager<br/>cmd/kube-controller-manager] etcd[(etcd<br/>External)] end subgraph \"Node Components\" Kubelet[Kubelet<br/>cmd/kubelet] Proxy[Kube Proxy<br/>cmd/kube-proxy] Runtime[Container Runtime<br/>External/CRI] end subgraph \"Client Tools\" kubectl[kubectl<br/>cmd/kubectl] end subgraph \"Cloud Integration\" CCM[Cloud Controller Manager<br/>cmd/cloud-controller-manager] end kubectl -->|REST API| API API -->|Persist| etcd API -->|Watch/Update| Scheduler API -->|Watch/Update| CM API -->|Watch/Update| CCM API -->|Watch/Update| Kubelet Kubelet -->|Status| API Kubelet -->|CRI| Runtime Kubelet -->|Manage| Proxy Proxy -->|Network Rules| Runtime","title":"Components Overview"},{"location":"components/overview.html#components-overview","text":"","title":"Components Overview"},{"location":"components/overview.html#architecture-overview","text":"","title":"Architecture Overview"},{"location":"components/overview.html#architecture-overview_1","text":"","title":"Architecture Overview"},{"location":"components/overview.html#kubernetes-architecture","text":"","title":"Kubernetes Architecture"},{"location":"components/overview.html#executive-summary","text":"Kubernetes is a production-grade container orchestration system designed to automate the deployment, scaling, and management of containerized applications. It provides a platform-agnostic way to manage clusters of hosts (nodes) and the workloads running on them. The system follows a decoupled, asynchronous, and declarative design. Users describe the \"desired state\" of the system through the API, and various independent controllers work continuously to transition the \"actual state\" toward that desired state. This reconciliation loop is the fundamental pattern of Kubernetes.","title":"Executive Summary"},{"location":"components/overview.html#system-purpose-design-philosophy","text":"Problem Solved: Managing microservices at scale, handling failures automatically, and optimizing resource utilization across a cluster of machines. Design Goals: Scalability: Capable of managing thousands of nodes and tens of thousands of pods. High Availability: No single point of failure in the control plane. Extensibility: Almost every component can be replaced or extended (CRDs, Admission Webhooks, CNI, CSI). Portability: Runs on public clouds, private clouds, and bare metal.","title":"System Purpose &amp; Design Philosophy"},{"location":"components/overview.html#architecture-at-a-glance","text":"","title":"Architecture at a Glance"},{"location":"components/overview.html#architectural-style","text":"Kubernetes uses a Modular Monorepo structure. It is composed of a central Control Plane that manages the cluster and a set of Nodes that run the actual workloads. Communication is centralized through the API Server; no other control plane component talks directly to etcd or to each other.","title":"Architectural Style"},{"location":"components/overview.html#core-subsystems","text":"API Server ( cmd/kube-apiserver ) - The central gateway for all cluster operations. etcd (External) - Distributed storage for cluster state. Scheduler ( cmd/kube-scheduler ) - Decides where to place workloads. Controller Manager ( cmd/kube-controller-manager ) - Handles routine cluster tasks (node management, replication). Kubelet ( cmd/kubelet ) - The primary agent running on each node. Kube Proxy ( cmd/kube-proxy ) - Manages network rules on nodes.","title":"Core Subsystems"},{"location":"components/overview.html#detailed-component-analysis","text":"","title":"Detailed Component Analysis"},{"location":"components/overview.html#component-api-server","text":"Purpose: Serves the Kubernetes API and acts as the \"brain\" of the cluster. Location: cmd/kube-apiserver Key Responsibilities: - Validates and configures data for API objects. - Provides RESTful entry points for clients and other components. - Manages authentication, authorization, and admission control. - Directly interacts with etcd for persistence. Core Abstractions: - GenericAPIServer - The base server logic. - Registry - Logic for storing and retrieving objects from etcd. Entry Points: - cmd/kube-apiserver/main.go -> app.NewAPIServerCommand()","title":"Component: API Server"},{"location":"components/overview.html#component-scheduler","text":"Purpose: Assigns unscheduled Pods to Nodes. Location: cmd/kube-scheduler Key Responsibilities: - Filters nodes (Predicates) based on resource requirements, constraints, and affinity. - Ranks remaining nodes (Priorities) to find the best fit. - Updates the Pod object with the selected Node name (Binding). Extension Points: - Scheduling Framework - Allows adding custom plugins for sorting, filtering, and scoring nodes.","title":"Component: Scheduler"},{"location":"components/overview.html#component-kubelet","text":"Purpose: Ensures that containers are running in a Pod on a specific node. Location: cmd/kubelet Key Responsibilities: - Watches the API Server for Pods assigned to its node. - Interacts with the Container Runtime (via CRI) to start/stop containers. - Reports node and pod status back to the API Server. - Performs health checks (Liveness/Readiness probes). Interactions: - Consumes: Pod definitions from API Server. - Provides: Container management on the host.","title":"Component: Kubelet"},{"location":"components/overview.html#component-controller-manager","text":"Purpose: Runs controller processes that regulate the state of the cluster. Location: cmd/kube-controller-manager Key Responsibilities: - Node Controller: Notices when nodes go down. - Job Controller: Watches for Job objects and creates Pods to run them. - EndpointSlice Controller: Populates EndpointSlices for services.","title":"Component: Controller Manager"},{"location":"components/overview.html#data-flow-communication","text":"","title":"Data Flow &amp; Communication"},{"location":"components/overview.html#primary-data-flows","text":"Desired State Update: User -> kubectl -> API Server -> etcd. Scheduling Loop: API Server (Watch) -> Scheduler -> API Server (Binding) -> etcd. Execution Loop: API Server (Watch) -> Kubelet -> Container Runtime (CRI).","title":"Primary Data Flows"},{"location":"components/overview.html#communication-patterns","text":"Synchronous: REST over HTTP/gRPC for API calls. Asynchronous: The Watch mechanism allows components to be notified of changes in real-time without polling. Persistence: All cluster state is stored in etcd .","title":"Communication Patterns"},{"location":"components/overview.html#directory-structure-guide","text":"kubernetes/ \u251c\u2500\u2500 cmd/ # Entry points for all binaries \u2502 \u251c\u2500\u2500 kube-apiserver/ # Control plane API server \u2502 \u251c\u2500\u2500 kubelet/ # Node agent \u2502 \u2514\u2500\u2500 kubectl/ # CLI tool \u251c\u2500\u2500 pkg/ # Core library code (private to this repo) \u2502 \u251c\u2500\u2500 apis/ # Internal API types and conversions \u2502 \u251c\u2500\u2500 controller/ # Logic for various controllers \u2502 \u2514\u2500\u2500 kubelet/ # Detailed implementation of the kubelet \u251c\u2500\u2500 api/ # OpenAPI and Swagger definitions \u251c\u2500\u2500 staging/ # Published libraries (k8s.io/*) \u2502 \u251c\u2500\u2500 src/k8s.io/api/ # Versioned API types \u2502 \u251c\u2500\u2500 src/k8s.io/client-go/# Go client library \u2502 \u2514\u2500\u2500 src/k8s.io/apiserver/# API server framework \u251c\u2500\u2500 test/ # Integration and E2E tests \u2514\u2500\u2500 hack/ # Scripts for building, linting, and codegen","title":"Directory Structure Guide"},{"location":"components/overview.html#key-interfaces-abstractions","text":"","title":"Key Interfaces &amp; Abstractions"},{"location":"components/overview.html#interface-cri-container-runtime-interface","text":"Location: staging/src/k8s.io/cri-api/pkg/apis/services.go (approx) Purpose: Standard interface between the Kubelet and the container runtime. Implementations: containerd, CRI-O, Docker (via shim).","title":"Interface: CRI (Container Runtime Interface)"},{"location":"components/overview.html#interface-informer","text":"Location: staging/src/k8s.io/client-go/informers/ Purpose: Provides a local cache and event notifications for API objects to minimize API server load.","title":"Interface: Informer"},{"location":"components/overview.html#development-guide","text":"","title":"Development Guide"},{"location":"components/overview.html#building","text":"Use the provided Makefile: make To build a specific component: make WHAT=cmd/kube-apiserver","title":"Building"},{"location":"components/overview.html#testing","text":"Unit Tests: go test ./pkg/scheduler/... Integration Tests: make test-integration E2E Tests: Use hack/ginkgo-e2e.sh or kind .","title":"Testing"},{"location":"components/overview.html#glossary","text":"Pod: The smallest deployable unit in Kubernetes, containing one or more containers. Node: A worker machine (VM or physical) in the cluster. CRD (Custom Resource Definition): A way to extend the Kubernetes API with your own objects. Admission Controller: A piece of code that intercepts requests to the API server prior to persistence.","title":"Glossary"},{"location":"components/overview.html#component-diagram","text":"View Mermaid Source graph TB subgraph \"Control Plane\" API[API Server<br/>cmd/kube-apiserver] Scheduler[Scheduler<br/>cmd/kube-scheduler] CM[Controller Manager<br/>cmd/kube-controller-manager] etcd[(etcd<br/>External)] end subgraph \"Node Components\" Kubelet[Kubelet<br/>cmd/kubelet] Proxy[Kube Proxy<br/>cmd/kube-proxy] Runtime[Container Runtime<br/>External/CRI] end subgraph \"Client Tools\" kubectl[kubectl<br/>cmd/kubectl] end subgraph \"Cloud Integration\" CCM[Cloud Controller Manager<br/>cmd/cloud-controller-manager] end kubectl -->|REST API| API API -->|Persist| etcd API -->|Watch/Update| Scheduler API -->|Watch/Update| CM API -->|Watch/Update| CCM API -->|Watch/Update| Kubelet Kubelet -->|Status| API Kubelet -->|CRI| Runtime Kubelet -->|Manage| Proxy Proxy -->|Network Rules| Runtime","title":"Component Diagram"},{"location":"dataflow/overview.html","text":"Data Flow This page visualizes how data flows through the system. Data Flow Diagram View Mermaid Source sequenceDiagram participant User participant kubectl participant API as API Server participant etcd participant Scheduler participant Kubelet participant Runtime as Container Runtime User->>kubectl: kubectl apply -f pod.yaml kubectl->>API: POST /api/v1/pods API->>API: Authentication & Authorization API->>API: Admission Controllers (Mutate & Validate) API->>etcd: Store Pod (status: Pending) API-->>kubectl: 201 Created Note over Scheduler: Watches for Pods without nodeName API->>Scheduler: Watch Event: New Pod (Pending) Scheduler->>Scheduler: Predicates (Filter) & Priorities (Score) Scheduler->>API: POST /api/v1/pods/{name}/binding API->>etcd: Update Pod (nodeName: Node-A) Note over Kubelet: Watches for Pods assigned to its Node API->>Kubelet: Watch Event: Pod updated (nodeName: Node-A) Kubelet->>Kubelet: Admission & PLEG check Kubelet->>Runtime: RunPodSandbox & CreateContainer Runtime-->>Kubelet: Container Started Kubelet->>API: PATCH /api/v1/pods/{name}/status API->>etcd: Update Pod status (status: Running)","title":"Data Flow"},{"location":"dataflow/overview.html#data-flow","text":"This page visualizes how data flows through the system.","title":"Data Flow"},{"location":"dataflow/overview.html#data-flow-diagram","text":"View Mermaid Source sequenceDiagram participant User participant kubectl participant API as API Server participant etcd participant Scheduler participant Kubelet participant Runtime as Container Runtime User->>kubectl: kubectl apply -f pod.yaml kubectl->>API: POST /api/v1/pods API->>API: Authentication & Authorization API->>API: Admission Controllers (Mutate & Validate) API->>etcd: Store Pod (status: Pending) API-->>kubectl: 201 Created Note over Scheduler: Watches for Pods without nodeName API->>Scheduler: Watch Event: New Pod (Pending) Scheduler->>Scheduler: Predicates (Filter) & Priorities (Score) Scheduler->>API: POST /api/v1/pods/{name}/binding API->>etcd: Update Pod (nodeName: Node-A) Note over Kubelet: Watches for Pods assigned to its Node API->>Kubelet: Watch Event: Pod updated (nodeName: Node-A) Kubelet->>Kubelet: Admission & PLEG check Kubelet->>Runtime: RunPodSandbox & CreateContainer Runtime-->>Kubelet: Container Started Kubelet->>API: PATCH /api/v1/pods/{name}/status API->>etcd: Update Pod status (status: Running)","title":"Data Flow Diagram"},{"location":"src/ANALYSIS_SUMMARY.html","text":"Repository Analysis Summary Repository: tmp/kubernetes/kubernetes Analysis Depth: deep Timestamp: 20260117_162748 Status: \u2705 Success Generated Documentation Human-Readable Artifacts: - architecture.md - Architecture overview and design patterns - components.mermaid - Component relationship diagram - dataflow.mermaid - Data flow visualization - tech-stack.txt - Technology stack summary Technical Output Files logs/analysis_*.txt - Raw OpenCode output logs/metadata_*.json - Analysis metadata analysis_*.json - Structured output (JSON events) Next Steps Start here: 1. Open index.md for the main documentation entry point 2. Browse organized subpages (components.md, dataflow.md, tech-stack.md) 3. View rendered diagrams in the diagrams/ directory","title":"Repository Analysis Summary"},{"location":"src/ANALYSIS_SUMMARY.html#repository-analysis-summary","text":"Repository: tmp/kubernetes/kubernetes Analysis Depth: deep Timestamp: 20260117_162748 Status: \u2705 Success","title":"Repository Analysis Summary"},{"location":"src/ANALYSIS_SUMMARY.html#generated-documentation","text":"Human-Readable Artifacts: - architecture.md - Architecture overview and design patterns - components.mermaid - Component relationship diagram - dataflow.mermaid - Data flow visualization - tech-stack.txt - Technology stack summary","title":"Generated Documentation"},{"location":"src/ANALYSIS_SUMMARY.html#technical-output-files","text":"logs/analysis_*.txt - Raw OpenCode output logs/metadata_*.json - Analysis metadata analysis_*.json - Structured output (JSON events)","title":"Technical Output Files"},{"location":"src/ANALYSIS_SUMMARY.html#next-steps","text":"Start here: 1. Open index.md for the main documentation entry point 2. Browse organized subpages (components.md, dataflow.md, tech-stack.md) 3. View rendered diagrams in the diagrams/ directory","title":"Next Steps"},{"location":"src/raw/architecture.html","text":"Kubernetes Architecture Executive Summary Kubernetes is a production-grade container orchestration system designed to automate the deployment, scaling, and management of containerized applications. It provides a platform-agnostic way to manage clusters of hosts (nodes) and the workloads running on them. The system follows a decoupled, asynchronous, and declarative design. Users describe the \"desired state\" of the system through the API, and various independent controllers work continuously to transition the \"actual state\" toward that desired state. This reconciliation loop is the fundamental pattern of Kubernetes. System Purpose & Design Philosophy Problem Solved: Managing microservices at scale, handling failures automatically, and optimizing resource utilization across a cluster of machines. Design Goals: Scalability: Capable of managing thousands of nodes and tens of thousands of pods. High Availability: No single point of failure in the control plane. Extensibility: Almost every component can be replaced or extended (CRDs, Admission Webhooks, CNI, CSI). Portability: Runs on public clouds, private clouds, and bare metal. Architecture at a Glance Architectural Style Kubernetes uses a Modular Monorepo structure. It is composed of a central Control Plane that manages the cluster and a set of Nodes that run the actual workloads. Communication is centralized through the API Server; no other control plane component talks directly to etcd or to each other. Core Subsystems API Server ( cmd/kube-apiserver ) - The central gateway for all cluster operations. etcd (External) - Distributed storage for cluster state. Scheduler ( cmd/kube-scheduler ) - Decides where to place workloads. Controller Manager ( cmd/kube-controller-manager ) - Handles routine cluster tasks (node management, replication). Kubelet ( cmd/kubelet ) - The primary agent running on each node. Kube Proxy ( cmd/kube-proxy ) - Manages network rules on nodes. Detailed Component Analysis Component: API Server Purpose: Serves the Kubernetes API and acts as the \"brain\" of the cluster. Location: cmd/kube-apiserver Key Responsibilities: - Validates and configures data for API objects. - Provides RESTful entry points for clients and other components. - Manages authentication, authorization, and admission control. - Directly interacts with etcd for persistence. Core Abstractions: - GenericAPIServer - The base server logic. - Registry - Logic for storing and retrieving objects from etcd. Entry Points: - cmd/kube-apiserver/main.go -> app.NewAPIServerCommand() Component: Scheduler Purpose: Assigns unscheduled Pods to Nodes. Location: cmd/kube-scheduler Key Responsibilities: - Filters nodes (Predicates) based on resource requirements, constraints, and affinity. - Ranks remaining nodes (Priorities) to find the best fit. - Updates the Pod object with the selected Node name (Binding). Extension Points: - Scheduling Framework - Allows adding custom plugins for sorting, filtering, and scoring nodes. Component: Kubelet Purpose: Ensures that containers are running in a Pod on a specific node. Location: cmd/kubelet Key Responsibilities: - Watches the API Server for Pods assigned to its node. - Interacts with the Container Runtime (via CRI) to start/stop containers. - Reports node and pod status back to the API Server. - Performs health checks (Liveness/Readiness probes). Interactions: - Consumes: Pod definitions from API Server. - Provides: Container management on the host. Component: Controller Manager Purpose: Runs controller processes that regulate the state of the cluster. Location: cmd/kube-controller-manager Key Responsibilities: - Node Controller: Notices when nodes go down. - Job Controller: Watches for Job objects and creates Pods to run them. - EndpointSlice Controller: Populates EndpointSlices for services. Data Flow & Communication Primary Data Flows Desired State Update: User -> kubectl -> API Server -> etcd. Scheduling Loop: API Server (Watch) -> Scheduler -> API Server (Binding) -> etcd. Execution Loop: API Server (Watch) -> Kubelet -> Container Runtime (CRI). Communication Patterns Synchronous: REST over HTTP/gRPC for API calls. Asynchronous: The Watch mechanism allows components to be notified of changes in real-time without polling. Persistence: All cluster state is stored in etcd . Directory Structure Guide kubernetes/ \u251c\u2500\u2500 cmd/ # Entry points for all binaries \u2502 \u251c\u2500\u2500 kube-apiserver/ # Control plane API server \u2502 \u251c\u2500\u2500 kubelet/ # Node agent \u2502 \u2514\u2500\u2500 kubectl/ # CLI tool \u251c\u2500\u2500 pkg/ # Core library code (private to this repo) \u2502 \u251c\u2500\u2500 apis/ # Internal API types and conversions \u2502 \u251c\u2500\u2500 controller/ # Logic for various controllers \u2502 \u2514\u2500\u2500 kubelet/ # Detailed implementation of the kubelet \u251c\u2500\u2500 api/ # OpenAPI and Swagger definitions \u251c\u2500\u2500 staging/ # Published libraries (k8s.io/*) \u2502 \u251c\u2500\u2500 src/k8s.io/api/ # Versioned API types \u2502 \u251c\u2500\u2500 src/k8s.io/client-go/# Go client library \u2502 \u2514\u2500\u2500 src/k8s.io/apiserver/# API server framework \u251c\u2500\u2500 test/ # Integration and E2E tests \u2514\u2500\u2500 hack/ # Scripts for building, linting, and codegen Key Interfaces & Abstractions Interface: CRI (Container Runtime Interface) Location: staging/src/k8s.io/cri-api/pkg/apis/services.go (approx) Purpose: Standard interface between the Kubelet and the container runtime. Implementations: containerd, CRI-O, Docker (via shim). Interface: Informer Location: staging/src/k8s.io/client-go/informers/ Purpose: Provides a local cache and event notifications for API objects to minimize API server load. Development Guide Building Use the provided Makefile: make To build a specific component: make WHAT=cmd/kube-apiserver Testing Unit Tests: go test ./pkg/scheduler/... Integration Tests: make test-integration E2E Tests: Use hack/ginkgo-e2e.sh or kind . Glossary Pod: The smallest deployable unit in Kubernetes, containing one or more containers. Node: A worker machine (VM or physical) in the cluster. CRD (Custom Resource Definition): A way to extend the Kubernetes API with your own objects. Admission Controller: A piece of code that intercepts requests to the API server prior to persistence.","title":"Kubernetes Architecture"},{"location":"src/raw/architecture.html#kubernetes-architecture","text":"","title":"Kubernetes Architecture"},{"location":"src/raw/architecture.html#executive-summary","text":"Kubernetes is a production-grade container orchestration system designed to automate the deployment, scaling, and management of containerized applications. It provides a platform-agnostic way to manage clusters of hosts (nodes) and the workloads running on them. The system follows a decoupled, asynchronous, and declarative design. Users describe the \"desired state\" of the system through the API, and various independent controllers work continuously to transition the \"actual state\" toward that desired state. This reconciliation loop is the fundamental pattern of Kubernetes.","title":"Executive Summary"},{"location":"src/raw/architecture.html#system-purpose-design-philosophy","text":"Problem Solved: Managing microservices at scale, handling failures automatically, and optimizing resource utilization across a cluster of machines. Design Goals: Scalability: Capable of managing thousands of nodes and tens of thousands of pods. High Availability: No single point of failure in the control plane. Extensibility: Almost every component can be replaced or extended (CRDs, Admission Webhooks, CNI, CSI). Portability: Runs on public clouds, private clouds, and bare metal.","title":"System Purpose &amp; Design Philosophy"},{"location":"src/raw/architecture.html#architecture-at-a-glance","text":"","title":"Architecture at a Glance"},{"location":"src/raw/architecture.html#architectural-style","text":"Kubernetes uses a Modular Monorepo structure. It is composed of a central Control Plane that manages the cluster and a set of Nodes that run the actual workloads. Communication is centralized through the API Server; no other control plane component talks directly to etcd or to each other.","title":"Architectural Style"},{"location":"src/raw/architecture.html#core-subsystems","text":"API Server ( cmd/kube-apiserver ) - The central gateway for all cluster operations. etcd (External) - Distributed storage for cluster state. Scheduler ( cmd/kube-scheduler ) - Decides where to place workloads. Controller Manager ( cmd/kube-controller-manager ) - Handles routine cluster tasks (node management, replication). Kubelet ( cmd/kubelet ) - The primary agent running on each node. Kube Proxy ( cmd/kube-proxy ) - Manages network rules on nodes.","title":"Core Subsystems"},{"location":"src/raw/architecture.html#detailed-component-analysis","text":"","title":"Detailed Component Analysis"},{"location":"src/raw/architecture.html#component-api-server","text":"Purpose: Serves the Kubernetes API and acts as the \"brain\" of the cluster. Location: cmd/kube-apiserver Key Responsibilities: - Validates and configures data for API objects. - Provides RESTful entry points for clients and other components. - Manages authentication, authorization, and admission control. - Directly interacts with etcd for persistence. Core Abstractions: - GenericAPIServer - The base server logic. - Registry - Logic for storing and retrieving objects from etcd. Entry Points: - cmd/kube-apiserver/main.go -> app.NewAPIServerCommand()","title":"Component: API Server"},{"location":"src/raw/architecture.html#component-scheduler","text":"Purpose: Assigns unscheduled Pods to Nodes. Location: cmd/kube-scheduler Key Responsibilities: - Filters nodes (Predicates) based on resource requirements, constraints, and affinity. - Ranks remaining nodes (Priorities) to find the best fit. - Updates the Pod object with the selected Node name (Binding). Extension Points: - Scheduling Framework - Allows adding custom plugins for sorting, filtering, and scoring nodes.","title":"Component: Scheduler"},{"location":"src/raw/architecture.html#component-kubelet","text":"Purpose: Ensures that containers are running in a Pod on a specific node. Location: cmd/kubelet Key Responsibilities: - Watches the API Server for Pods assigned to its node. - Interacts with the Container Runtime (via CRI) to start/stop containers. - Reports node and pod status back to the API Server. - Performs health checks (Liveness/Readiness probes). Interactions: - Consumes: Pod definitions from API Server. - Provides: Container management on the host.","title":"Component: Kubelet"},{"location":"src/raw/architecture.html#component-controller-manager","text":"Purpose: Runs controller processes that regulate the state of the cluster. Location: cmd/kube-controller-manager Key Responsibilities: - Node Controller: Notices when nodes go down. - Job Controller: Watches for Job objects and creates Pods to run them. - EndpointSlice Controller: Populates EndpointSlices for services.","title":"Component: Controller Manager"},{"location":"src/raw/architecture.html#data-flow-communication","text":"","title":"Data Flow &amp; Communication"},{"location":"src/raw/architecture.html#primary-data-flows","text":"Desired State Update: User -> kubectl -> API Server -> etcd. Scheduling Loop: API Server (Watch) -> Scheduler -> API Server (Binding) -> etcd. Execution Loop: API Server (Watch) -> Kubelet -> Container Runtime (CRI).","title":"Primary Data Flows"},{"location":"src/raw/architecture.html#communication-patterns","text":"Synchronous: REST over HTTP/gRPC for API calls. Asynchronous: The Watch mechanism allows components to be notified of changes in real-time without polling. Persistence: All cluster state is stored in etcd .","title":"Communication Patterns"},{"location":"src/raw/architecture.html#directory-structure-guide","text":"kubernetes/ \u251c\u2500\u2500 cmd/ # Entry points for all binaries \u2502 \u251c\u2500\u2500 kube-apiserver/ # Control plane API server \u2502 \u251c\u2500\u2500 kubelet/ # Node agent \u2502 \u2514\u2500\u2500 kubectl/ # CLI tool \u251c\u2500\u2500 pkg/ # Core library code (private to this repo) \u2502 \u251c\u2500\u2500 apis/ # Internal API types and conversions \u2502 \u251c\u2500\u2500 controller/ # Logic for various controllers \u2502 \u2514\u2500\u2500 kubelet/ # Detailed implementation of the kubelet \u251c\u2500\u2500 api/ # OpenAPI and Swagger definitions \u251c\u2500\u2500 staging/ # Published libraries (k8s.io/*) \u2502 \u251c\u2500\u2500 src/k8s.io/api/ # Versioned API types \u2502 \u251c\u2500\u2500 src/k8s.io/client-go/# Go client library \u2502 \u2514\u2500\u2500 src/k8s.io/apiserver/# API server framework \u251c\u2500\u2500 test/ # Integration and E2E tests \u2514\u2500\u2500 hack/ # Scripts for building, linting, and codegen","title":"Directory Structure Guide"},{"location":"src/raw/architecture.html#key-interfaces-abstractions","text":"","title":"Key Interfaces &amp; Abstractions"},{"location":"src/raw/architecture.html#interface-cri-container-runtime-interface","text":"Location: staging/src/k8s.io/cri-api/pkg/apis/services.go (approx) Purpose: Standard interface between the Kubelet and the container runtime. Implementations: containerd, CRI-O, Docker (via shim).","title":"Interface: CRI (Container Runtime Interface)"},{"location":"src/raw/architecture.html#interface-informer","text":"Location: staging/src/k8s.io/client-go/informers/ Purpose: Provides a local cache and event notifications for API objects to minimize API server load.","title":"Interface: Informer"},{"location":"src/raw/architecture.html#development-guide","text":"","title":"Development Guide"},{"location":"src/raw/architecture.html#building","text":"Use the provided Makefile: make To build a specific component: make WHAT=cmd/kube-apiserver","title":"Building"},{"location":"src/raw/architecture.html#testing","text":"Unit Tests: go test ./pkg/scheduler/... Integration Tests: make test-integration E2E Tests: Use hack/ginkgo-e2e.sh or kind .","title":"Testing"},{"location":"src/raw/architecture.html#glossary","text":"Pod: The smallest deployable unit in Kubernetes, containing one or more containers. Node: A worker machine (VM or physical) in the cluster. CRD (Custom Resource Definition): A way to extend the Kubernetes API with your own objects. Admission Controller: A piece of code that intercepts requests to the API server prior to persistence.","title":"Glossary"},{"location":"tech-stack/overview.html","text":"Technology Stack Project: Kubernetes Last Updated: 2026-01-17 == Languages == - Go 1.25.0 - Primary language for all core components == Core Frameworks & Libraries == - k8s.io/apiserver - Framework for building Kubernetes-style API servers - k8s.io/client-go - Go clients for talking to Kubernetes API - k8s.io/apimachinery - Shared logic for API serialization, schema, and more - cobra - CLI framework for kubectl and other components - gRPC - Used for internal communication (CRI, CSI, KMS) == Build System == - Make - Entry point for build commands - Docker/Buildkit - Used for containerized builds - Go modules - Dependency management == Testing == - Go testing package - Unit and integration tests - Ginkgo/Gomega - BDD framework for End-to-End (e2e) tests == Infrastructure & Deployment == - etcd - Distributed key-value store for cluster state - Container Runtime (Docker, containerd, CRI-O) - Executes containers - Cloud Providers (AWS, GCP, Azure, etc.) - Infrastructure backends == Documentation == - Markdown - Primary documentation format - Hugo - Used for the public website (kubernetes.io) - OpenAPI/Swagger - API documentation == External Dependencies (Runtime) == - etcd - State storage - CoreDNS - Cluster DNS - CNI Plugins - Networking - CSI Drivers - Storage == Development Tools == - kind (Kubernetes in Docker) - Local cluster development - minikube - Local cluster development - hack/ scripts - Various development utilities (linting, code generation, etc.)","title":"Technology Stack"},{"location":"tech-stack/overview.html#technology-stack","text":"","title":"Technology Stack"},{"location":"tech-stack/overview.html#project-kubernetes","text":"","title":"Project: Kubernetes"},{"location":"tech-stack/overview.html#last-updated-2026-01-17","text":"== Languages == - Go 1.25.0 - Primary language for all core components == Core Frameworks & Libraries == - k8s.io/apiserver - Framework for building Kubernetes-style API servers - k8s.io/client-go - Go clients for talking to Kubernetes API - k8s.io/apimachinery - Shared logic for API serialization, schema, and more - cobra - CLI framework for kubectl and other components - gRPC - Used for internal communication (CRI, CSI, KMS) == Build System == - Make - Entry point for build commands - Docker/Buildkit - Used for containerized builds - Go modules - Dependency management == Testing == - Go testing package - Unit and integration tests - Ginkgo/Gomega - BDD framework for End-to-End (e2e) tests == Infrastructure & Deployment == - etcd - Distributed key-value store for cluster state - Container Runtime (Docker, containerd, CRI-O) - Executes containers - Cloud Providers (AWS, GCP, Azure, etc.) - Infrastructure backends == Documentation == - Markdown - Primary documentation format - Hugo - Used for the public website (kubernetes.io) - OpenAPI/Swagger - API documentation == External Dependencies (Runtime) == - etcd - State storage - CoreDNS - Cluster DNS - CNI Plugins - Networking - CSI Drivers - Storage == Development Tools == - kind (Kubernetes in Docker) - Local cluster development - minikube - Local cluster development - hack/ scripts - Various development utilities (linting, code generation, etc.)","title":"Last Updated: 2026-01-17"}]}